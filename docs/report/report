Seguendo l'architettura software descritta nel documento delle specifiche, abbiamo in primo luogo sviluppato un db MySQL sulla base del diagramma ER elaborato. In seguito e' stato riempito con dei dati dummy generati tramite `http://filldb.info/`, inconsistenti sotto alcuni aspetti (per via dell'ordine con cui vengono generati i dati e dalla flessibilita' del servizio), ma sufficienti ad un successivo primo test funzionale dell'applicativo.
Lo sviluppo e' continuando con il set-up delle dipendenze Java (Spring Boot, JDBC, Junit e Google Gson), poi sono state scritte le prime funzioni che utilizzavano il database e, allo stesso tempo, fornivano delle API accessibili tramite una richiesta HTTP di tipo appropriato. Non avendo a disposizione un frontend con cui effettuare le prove di funzionamento, e' stato utilizzato `curl` scegliendo manualmente il tipo di richiesta e i dati da inviare.
Il lavoro si e' poi diviso tra lo sviluppo della webapp React e la scrittura del Database Adapter e delle API.
Per quanto riguarda il frontend, si e' fatto di uso di librerie molto comuni, evitando di entrare troppo nel dettaglio.
La struttura della pagina e' stata ottenuta tramite l'utilizzo della libreria Bootstrap.

Dal lato sicurezza, al momento le password nel database sono in chiaro, sia perche' sono state generate in questo modo nei dummy data, sia per comodita' di sviluppo (utilizzando un account generato automaticamente, altrimenti, con la password hashed, non sarebbe stato possibile utilizzarlo). In produzione, si dovrebbe introdurre una funzione di hashing, come ad esempio puo' esserla SHA-256. Il tipo relativo alla password nel database e' un VARCHAR(64) esattamente per questo motivo.

Un problema che si e' posto dopo l'inizio dello sviluppo fronted riguardava il mantenimento della sessione. Si e' scelto di utilizzare un token, sessionId, generato da funzioni crittograficamente sicure e in maniera completamente pseudo-randomica (non viene utilizzato username, userId o altri dati per la generazione del token). Il sessionId, dalla validita' di 5 giorni, viene generato e inviato all'utente una volta che questo completa, con successo, il login. Le richieste effettuate dall'utente loggato conterranno tutte il sessionId come uno dei parametri. Lato server, la tabella "Sessions" mantiene l'associazione (userId, sessionId). All'arrivo di ogni richiesta effettuabile solo da utente registrato, il sessionId viene letto, viene cercato nel database e una specifica funzione ritorna lo userId che viene poi utilizzato per effettuare la relativa richiesta.

L'evento time-based riguarda l'aggiornamento delle chat e dei messaggi.
Ogni secondo viene richiesto al server l'invio di tutte le chat di cui l'utente fa parte, ordinate per ultima attivita', in modo tale che risulti come prima chat quella con un messaggio inviato piu' di recente oppure creata da poco.
Ogni 500ms viene inviata una richiesta al server per controllare l'esistenza di nuovi messaggi. Poiche' la mole dei messaggi e', in un contesto reale, innumerevole volte piu' grande del numero delle chat, la richiesta comporta un carico non indifferente sul server. Per questo motivo, la funzione di controllo messaggi permette di specificare un timestamp da cui partire e/o un numero massimo di messaggi da ricevere.
Una piccola considerazione: il carico sul server resta comunque elevato e delle modifiche per alleggerirlo sono possibili, per questo motivo riteniamo che ci sia ancora molto margine di miglioramento sotto questo aspetto.